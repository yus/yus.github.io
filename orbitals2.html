<!DOCTYPE html>
<html lang="en">
<head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/2.0.4/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #0a0a1a;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Arial', sans-serif;
        }
        canvas {
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 150, 255, 0.3);
        }
        .title {
            position: absolute;
            top: 20px;
            color: white;
            text-align: center;
            font-size: 24px;
            text-shadow: 0 0 10px rgba(0, 150, 255, 0.8);
            z-index: 10;
        }
        .controls {
            position: absolute;
            bottom: 20px;
            color: white;
            text-align: center;
            background: rgba(0, 30, 60, 0.7);
            padding: 10px 20px;
            border-radius: 10px;
            backdrop-filter: blur(5px);
            z-index: 10;
        }
    </style>
</head>
<body>
    <div class="title">Orbiting Cube with Fixed GPU Rendering</div>
    <div class="controls">
        <p>Click and drag to orbit the cube</p>
        <p>Fixed renderer reference and depth testing</p>
    </div>
    <script>
        let angleX = 0;
        let angleY = 0;
        let targetAngleX = 0;
        let targetAngleY = 0;
        let inertia = 0.05;
        let impulseStrength = 0.01;

        // Scene geometry
        let cubeGeometries = [];
        let trails = [];
        let cubeSize = 200;
        let cellSize = cubeSize / 4;
        let lastTime = 0;

        function setup() {
            createCanvas(windowWidth * 0.9, windowHeight * 0.9, WEBGL);
            angleMode(RADIANS);

            // Enable depth testing using the correct p5.js method
            setAttributes('depth', true);

            // Create cube geometries for each face (to avoid z-fighting)
            for (let face = 0; face < 6; face++) {
                cubeGeometries.push(createFaceGeometry(face));
            }

            // Initialize trails for each cell
            for (let face = 0; face < 6; face++) {
                for (let i = 0; i < 4; i++) {
                    for (let j = 0; j < 4; j++) {
                        trails.push({
                            face: face,
                            x: i,
                            y: j,
                            points: [],
                            color: color(
                                random(150, 255),
                                random(150, 255),
                                random(150, 255),
                                200
                            )
                        });
                    }
                }
            }

            // Set initial angles for better starting view
            targetAngleX = 0.5;
            targetAngleY = 0.5;
        }

        function createFaceGeometry(face) {
            let g = new p5.Geometry();
            let halfSize = cubeSize / 2;
            let halfCell = cellSize / 2;
            let offset = 0.5; // Small offset to prevent z-fighting

            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    let x = -halfSize + (i * cellSize) + halfCell;
                    let y = -halfSize + (j * cellSize) + halfCell;
                    let z = halfSize + offset;

                    // Define cell color based on position
                    let cellColor = color(
                        40 + i * 30,
                        40 + j * 30,
                        150,
                        200
                    );

                    let dotColor = color(220, 220, 255);

                    // Transform based on face with proper orientation
                    let positions = [];
                    switch(face) {
                        case 0: // Front
                            positions = [
                                createVector(x - halfCell, y - halfCell, z),
                                createVector(x + halfCell, y - halfCell, z),
                                createVector(x + halfCell, y + halfCell, z),
                                createVector(x - halfCell, y + halfCell, z),
                                createVector(x, y, z + 0.5) // Center dot
                            ];
                            break;
                        case 1: // Back
                            positions = [
                                createVector(x - halfCell, y - halfCell, -z),
                                createVector(x + halfCell, y - halfCell, -z),
                                createVector(x + halfCell, y + halfCell, -z),
                                createVector(x - halfCell, y + halfCell, -z),
                                createVector(x, y, -z - 0.5) // Center dot
                            ];
                            break;
                        case 2: // Right
                            positions = [
                                createVector(z, y - halfCell, x - halfCell),
                                createVector(z, y - halfCell, x + halfCell),
                                createVector(z, y + halfCell, x + halfCell),
                                createVector(z, y + halfCell, x - halfCell),
                                createVector(z + 0.5, y, x) // Center dot
                            ];
                            break;
                        case 3: // Left
                            positions = [
                                createVector(-z, y - halfCell, x - halfCell),
                                createVector(-z, y - halfCell, x + halfCell),
                                createVector(-z, y + halfCell, x + halfCell),
                                createVector(-z, y + halfCell, x - halfCell),
                                createVector(-z - 0.5, y, x) // Center dot
                            ];
                            break;
                        case 4: // Top
                            positions = [
                                createVector(x - halfCell, -z, y - halfCell),
                                createVector(x + halfCell, -z, y - halfCell),
                                createVector(x + halfCell, -z, y + halfCell),
                                createVector(x - halfCell, -z, y + halfCell),
                                createVector(x, -z - 0.5, y) // Center dot
                            ];
                            break;
                        case 5: // Bottom
                            positions = [
                                createVector(x - halfCell, z, y - halfCell),
                                createVector(x + halfCell, z, y - halfCell),
                                createVector(x + halfCell, z, y + halfCell),
                                createVector(x - halfCell, z, y + halfCell),
                                createVector(x, z + 0.5, y) // Center dot
                            ];
                            break;
                    }

                    // Add vertices for the cell
                    for (let k = 0; k < 4; k++) {
                        g.vertices.push(positions[k]);
                        g.vertexColors.push(cellColor);
                    }

                    // Add center dot
                    g.vertices.push(positions[4]);
                    g.vertexColors.push(dotColor);

                    // Add faces (two triangles per cell)
                    let baseIndex = (i * 4 + j) * 5;
                    g.faces.push([baseIndex, baseIndex + 1, baseIndex + 2]);
                    g.faces.push([baseIndex, baseIndex + 2, baseIndex + 3]);
                }
            }

            freeGeometry(g);
            return g;
        }

        function draw() {
            // Clear with depth buffer
            clear();
            background(10, 15, 30);

            // Draw radial gradient manually
            drawGradientBackground();

            // Smooth rotation with inertia
            let now = millis();
            let deltaTime = now - lastTime;
            lastTime = now;

            // Frame-rate independent rotation
            angleX = lerp(angleX, targetAngleX, inertia * (deltaTime / 16.67));
            angleY = lerp(angleY, targetAngleY, inertia * (deltaTime / 16.67));

            rotateX(angleX);
            rotateY(angleY);

            // Draw the cube using separate geometries for each face
            drawCube();

            // Update and draw trails
            updateTrails();
            drawTrails();
        }

        function drawGradientBackground() {
            // Draw gradient using multiple circles
            push();
            resetMatrix();
            noStroke();

            let centerX = width/2;
            let centerY = height/2;
            let maxRadius = max(width, height) / 2;

            for (let r = maxRadius; r > 0; r -= 20) {
                let alpha = map(r, 0, maxRadius, 200, 10);
                fill(10, 15, 30, alpha);
                ellipse(centerX, centerY, r*2, r*2);
            }

            pop();
        }

        function drawCube() {
            push();
            noStroke();

            // Draw each face with its own geometry
            for (let face = 0; face < 6; face++) {
                let g = cubeGeometries[face];

                // Draw cells
                beginShape(TRIANGLES);
                for (let i = 0; i < g.faces.length; i++) {
                    let faceIndices = g.faces[i];
                    for (let j = 0; j < 3; j++) {
                        let idx = faceIndices[j];
                        fill(g.vertexColors[idx]);
                        vertex(g.vertices[idx].x, g.vertices[idx].y, g.vertices[idx].z);
                    }
                }
                endShape();

                // Draw center dots
                beginShape(POINTS);
                strokeWeight(3);
                for (let i = 4; i < g.vertices.length; i += 5) {
                    stroke(g.vertexColors[i]);
                    vertex(g.vertices[i].x, g.vertices[i].y, g.vertices[i].z);
                }
                endShape();
            }

            pop();
        }

        function updateTrails() {
            // For each trail, record its current position
            for (let t of trails) {
                let pos = getCellPosition(t.face, t.x, t.y);

                // Add new point
                t.points.push({
                    position: pos.copy(),
                    life: 1.0
                });

                // Update all points and remove dead ones
                for (let i = t.points.length - 1; i >= 0; i--) {
                    let p = t.points[i];
                    p.life -= 0.01;

                    // Remove if life is over
                    if (p.life <= 0) {
                        t.points.splice(i, 1);
                    }
                }

                // Limit trail length
                if (t.points.length > 30) {
                    t.points.shift();
                }
            }
        }

        function drawTrails() {
            // Draw all trails as lines with proper depth testing
            for (let t of trails) {
                if (t.points.length > 1) {
                    // Use LINE_STRIP for connected lines
                    beginShape(LINE_STRIP);
                    for (let i = 0; i < t.points.length; i++) {
                        let p = t.points[i];
                        let alpha = 255 * p.life;
                        stroke(red(t.color), green(t.color), blue(t.color), alpha);
                        strokeWeight(2 * p.life);
                        vertex(p.position.x, p.position.y, p.position.z);
                    }
                    endShape();
                }
            }
        }

        function getCellPosition(face, x, y) {
            // Calculate the world position of a cell
            let halfCube = cubeSize / 2;
            let cellX = -halfCube + (x * cellSize) + cellSize/2;
            let cellY = -halfCube + (y * cellSize) + cellSize/2;
            let cellZ = halfCube + 0.5; // Offset to prevent z-fighting

            let pos = createVector(cellX, cellY, cellZ);

            // Transform based on face
            switch(face) {
                case 0: // Front
                    break;
                case 1: // Back
                    pos.z = -pos.z;
                    break;
                case 2: // Right
                    pos = createVector(cellZ, cellY, -cellX);
                    break;
                case 3: // Left
                    pos = createVector(-cellZ, cellY, cellX);
                    break;
                case 4: // Top
                    pos = createVector(cellX, -cellZ, -cellY);
                    break;
                case 5: // Bottom
                    pos = createVector(cellX, cellZ, cellY);
                    break;
            }

            // Apply current rotation
            return applyRotation(pos);
        }

        function applyRotation(pos) {
            // Apply the current rotation to a vector
            let rotated = pos.copy();

            // Rotate around X axis
            let y = rotated.y;
            let z = rotated.z;
            rotated.y = y * cos(angleX) - z * sin(angleX);
            rotated.z = y * sin(angleX) + z * cos(angleX);

            // Rotate around Y axis
            let x = rotated.x;
            z = rotated.z;
            rotated.x = x * cos(angleY) + z * sin(angleY);
            rotated.z = -x * sin(angleY) + z * cos(angleY);

            return rotated;
        }

        function mouseDragged() {
            // Update target angles based on mouse movement with stronger impulse
            let deltaX = (pmouseY - mouseY) * impulseStrength;
            let deltaY = (mouseX - pmouseX) * impulseStrength;

            targetAngleX += deltaX;
            targetAngleY += deltaY;

            // Constrain X rotation to avoid flipping
            targetAngleX = constrain(targetAngleX, -PI/2, PI/2);
        }

        function windowResized() {
            resizeCanvas(windowWidth * 0.9, windowHeight * 0.9);
        }
    </script>
</body>
</html>
