<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mobile Collidoscope</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #000;
            color: white;
            height: 100vh;
            overflow: hidden;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            max-width: 100%;
        }

        /* Header */
        .header {
            padding: 12px 16px;
            background: #111;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }

        .title {
            font-size: 18px;
            font-weight: 600;
        }

        .controls-top {
            display: flex;
            gap: 8px;
        }

        .icon-btn {
            width: 36px;
            height: 36px;
            border: none;
            background: #222;
            color: white;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            cursor: pointer;
        }

        /* Particle Field */
        .particle-field {
            flex: 1;
            background: #000;
            position: relative;
            overflow: hidden;
            min-height: 200px;
            border-bottom: 1px solid #333;
        }

        #particleCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* Recording Track */
        .recording-section {
            background: #111;
            padding: 12px 16px;
            border-bottom: 1px solid #333;
        }

        .waveform-container {
            background: #1a1a1a;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 12px;
        }

        #waveformCanvas {
            width: 100%;
            height: 60px;
            background: #000;
            border-radius: 4px;
        }

        .playback-controls {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .scrubber {
            flex: 1;
            height: 4px;
            background: #333;
            border-radius: 2px;
            position: relative;
            cursor: pointer;
        }

        .scrubber-progress {
            position: absolute;
            height: 100%;
            background: #4CAF50;
            border-radius: 2px;
            width: 0%;
        }

        .scrubber-handle {
            position: absolute;
            width: 16px;
            height: 16px;
            background: #4CAF50;
            border-radius: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            cursor: grab;
        }

        .loop-marker {
            position: absolute;
            width: 2px;
            height: 100%;
            background: #FF9800;
            top: 0;
            cursor: col-resize;
        }

        .transport-btn {
            width: 44px;
            height: 44px;
            border: none;
            border-radius: 50%;
            background: #4CAF50;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            cursor: pointer;
        }

        .transport-btn.stop {
            background: #f44336;
        }

        /* Plugins Section */
        .plugins-section {
            background: #111;
            padding: 12px 16px;
            flex-shrink: 0;
        }

        .plugins-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .plugin-tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }

        .plugin-tab {
            padding: 8px 16px;
            background: #222;
            border: none;
            color: white;
            border-radius: 20px;
            font-size: 14px;
            cursor: pointer;
        }

        .plugin-tab.active {
            background: #4CAF50;
        }

        .graph-editor {
            background: #1a1a1a;
            border-radius: 8px;
            padding: 12px;
            height: 120px;
        }

        #graphCanvas {
            width: 100%;
            height: 100%;
            background: #000;
            border-radius: 4px;
        }

        /* Bottom Controls */
        .bottom-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            padding: 12px 16px;
            background: #111;
            border-top: 1px solid #333;
        }

        .control-btn {
            padding: 12px;
            background: #222;
            border: none;
            color: white;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
        }

        .control-btn.primary {
            background: #4CAF50;
        }

        /* Touch-friendly enhancements */
        @media (max-width: 768px) {
            .icon-btn, .transport-btn, .control-btn {
                min-height: 44px;
                min-width: 44px;
            }
            
            .particle-field {
                min-height: 150px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <div class="title">Collidoscope</div>
            <div class="controls-top">
                <button class="icon-btn" id="settingsBtn">‚öôÔ∏è</button>
                <button class="icon-btn" id="helpBtn">‚ùì</button>
            </div>
        </div>

        <!-- Particle Field -->
        <div class="particle-field">
            <canvas id="particleCanvas"></canvas>
        </div>

        <!-- Recording Track -->
        <div class="recording-section">
            <div class="waveform-container">
                <canvas id="waveformCanvas"></canvas>
            </div>
            
            <div class="playback-controls">
                <button class="transport-btn stop" id="stopBtn">‚ñ†</button>
                <button class="transport-btn" id="playBtn">‚ñ∂</button>
                
                <div class="scrubber" id="scrubber">
                    <div class="scrubber-progress" id="scrubberProgress"></div>
                    <div class="scrubber-handle" id="scrubberHandle"></div>
                    <div class="loop-marker" id="loopStart" style="left: 20%"></div>
                    <div class="loop-marker" id="loopEnd" style="left: 80%"></div>
                </div>
                
                <button class="transport-btn" id="loopBtn">üîÅ</button>
            </div>
        </div>

        <!-- Plugins Section -->
        <div class="plugins-section">
            <div class="plugins-header">
                <div>Audio Graph</div>
                <button class="icon-btn" id="addPluginBtn">+</button>
            </div>
            
            <div class="plugin-tabs">
                <button class="plugin-tab active">Filter</button>
                <button class="plugin-tab">Reverb</button>
                <button class="plugin-tab">Delay</button>
            </div>
            
            <div class="graph-editor">
                <canvas id="graphCanvas"></canvas>
            </div>
        </div>

        <!-- Bottom Controls -->
        <div class="bottom-controls">
            <button class="control-btn" id="recordBtn">‚óè Record</button>
            <button class="control-btn primary" id="generateBtn">‚ú® Generate</button>
        </div>
    </div>

    <script>
        class MobileCollidoscope {
            constructor() {
                this.audioContext = null;
                this.isRecording = false;
                this.isPlaying = false;
                this.audioData = [];
                this.currentTime = 0;
                this.duration = 10; // 10 seconds default
                this.loopStart = 2; // seconds
                this.loopEnd = 8; // seconds
                
                this.init();
            }

            init() {
                this.initCanvases();
                this.initAudio();
                this.initEventListeners();
                this.startAnimation();
            }

            initCanvases() {
                // Particle canvas
                this.particleCanvas = document.getElementById('particleCanvas');
                this.particleCtx = this.particleCanvas.getContext('2d');
                
                // Waveform canvas
                this.waveformCanvas = document.getElementById('waveformCanvas');
                this.waveformCtx = this.waveformCanvas.getContext('2d');
                
                // Graph canvas
                this.graphCanvas = document.getElementById('graphCanvas');
                this.graphCtx = this.graphCanvas.getContext('2d');
                
                this.resizeCanvases();
                window.addEventListener('resize', () => this.resizeCanvases());
            }

            resizeCanvases() {
                const particleField = document.querySelector('.particle-field');
                this.particleCanvas.width = particleField.clientWidth;
                this.particleCanvas.height = particleField.clientHeight;

                this.waveformCanvas.width = this.waveformCanvas.clientWidth;
                this.waveformCanvas.height = this.waveformCanvas.clientHeight;

                this.graphCanvas.width = this.graphCanvas.clientWidth;
                this.graphCanvas.height = this.graphCanvas.clientHeight;
            }

            async initAudio() {
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Wait for user interaction
                document.getElementById('generateBtn').addEventListener('click', async () => {
                    await this.audioContext.resume();
                    this.generateAudio();
                });
            }

            initEventListeners() {
                // Transport controls
                document.getElementById('playBtn').addEventListener('click', () => this.togglePlayback());
                document.getElementById('stopBtn').addEventListener('click', () => this.stopPlayback());
                document.getElementById('recordBtn').addEventListener('click', () => this.toggleRecording());
                document.getElementById('loopBtn').addEventListener('click', () => this.toggleLoop());

                // Scrubber interaction
                this.setupScrubber();
                
                // Plugin tabs
                document.querySelectorAll('.plugin-tab').forEach(tab => {
                    tab.addEventListener('click', (e) => this.switchPluginTab(e.target));
                });
            }

            setupScrubber() {
                const scrubber = document.getElementById('scrubber');
                const handle = document.getElementById('scrubberHandle');
                const loopStart = document.getElementById('loopStart');
                const loopEnd = document.getElementById('loopEnd');
                
                let isDragging = false;
                let dragTarget = null;

                const startDrag = (e) => {
                    isDragging = true;
                    const rect = scrubber.getBoundingClientRect();
                    const x = (e.clientX || e.touches[0].clientX) - rect.left;
                    
                    // Check what we're dragging
                    if (Math.abs(x - parseFloat(loopStart.style.left) * rect.width / 100) < 10) {
                        dragTarget = loopStart;
                    } else if (Math.abs(x - parseFloat(loopEnd.style.left) * rect.width / 100) < 10) {
                        dragTarget = loopEnd;
                    } else {
                        dragTarget = handle;
                    }
                };

                const doDrag = (e) => {
                    if (!isDragging || !dragTarget) return;
                    
                    const rect = scrubber.getBoundingClientRect();
                    const x = Math.max(0, Math.min(rect.width, (e.clientX || e.touches[0].clientX) - rect.left));
                    const percent = (x / rect.width) * 100;
                    
                    if (dragTarget === handle) {
                        this.currentTime = (percent / 100) * this.duration;
                        this.updateScrubber();
                    } else if (dragTarget === loopStart) {
                        this.loopStart = (percent / 100) * this.duration;
                        loopStart.style.left = percent + '%';
                    } else if (dragTarget === loopEnd) {
                        this.loopEnd = (percent / 100) * this.duration;
                        loopEnd.style.left = percent + '%';
                    }
                };

                const endDrag = () => {
                    isDragging = false;
                    dragTarget = null;
                };

                // Mouse events
                scrubber.addEventListener('mousedown', startDrag);
                document.addEventListener('mousemove', doDrag);
                document.addEventListener('mouseup', endDrag);

                // Touch events
                scrubber.addEventListener('touchstart', startDrag);
                document.addEventListener('touchmove', doDrag);
                document.addEventListener('touchend', endDrag);
            }

            updateScrubber() {
                const progress = (this.currentTime / this.duration) * 100;
                document.getElementById('scrubberProgress').style.width = progress + '%';
                document.getElementById('scrubberHandle').style.left = progress + '%';
            }

            togglePlayback() {
                this.isPlaying = !this.isPlaying;
                const playBtn = document.getElementById('playBtn');
                playBtn.textContent = this.isPlaying ? '‚è∏' : '‚ñ∂';
                
                if (this.isPlaying) {
                    this.startPlayback();
                }
            }

            startPlayback() {
                // Simulate playback
                const startTime = Date.now();
                const updatePlayback = () => {
                    if (!this.isPlaying) return;
                    
                    const elapsed = (Date.now() - startTime) / 1000;
                    this.currentTime = (elapsed % this.duration);
                    this.updateScrubber();
                    
                    // Loop logic
                    if (this.currentTime >= this.loopEnd) {
                        this.currentTime = this.loopStart;
                        const newStartTime = Date.now() - (this.loopStart * 1000);
                        startTime = newStartTime;
                    }
                    
                    requestAnimationFrame(updatePlayback);
                };
                updatePlayback();
            }

            stopPlayback() {
                this.isPlaying = false;
                this.currentTime = 0;
                this.updateScrubber();
                document.getElementById('playBtn').textContent = '‚ñ∂';
            }

            toggleRecording() {
                this.isRecording = !this.isRecording;
                const recordBtn = document.getElementById('recordBtn');
                recordBtn.style.background = this.isRecording ? '#f44336' : '#222';
                recordBtn.textContent = this.isRecording ? '‚èπ Stop' : '‚óè Record';
                
                if (this.isRecording) {
                    this.startRecording();
                }
            }

            startRecording() {
                // Simulate recording
                this.audioData = [];
                setTimeout(() => {
                    if (this.isRecording) {
                        this.generateWaveform();
                    }
                }, 1000);
            }

            toggleLoop() {
                const loopBtn = document.getElementById('loopBtn');
                const isLooping = loopBtn.style.background === '#4CAF50';
                loopBtn.style.background = isLooping ? '#222' : '#4CAF50';
            }

            switchPluginTab(selectedTab) {
                document.querySelectorAll('.plugin-tab').forEach(tab => {
                    tab.classList.remove('active');
                });
                selectedTab.classList.add('active');
                this.drawGraphEditor();
            }

            generateAudio() {
                // Generate some random audio data for visualization
                this.generateWaveform();
                this.drawGraphEditor();
                
                // Add some particles for visual feedback
                this.addParticles(5);
            }

            generateWaveform() {
                const ctx = this.waveformCtx;
                const width = this.waveformCanvas.width;
                const height = this.waveformCanvas.height;
                
                ctx.clearRect(0, 0, width, height);
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(0, 0, width, height);
                
                // Draw waveform
                ctx.beginPath();
                ctx.moveTo(0, height / 2);
                
                for (let x = 0; x < width; x++) {
                    const progress = x / width;
                    const noise = Math.sin(progress * 20 * Math.PI) * 0.7 + 
                                 Math.sin(progress * 47 * Math.PI) * 0.3;
                    const y = (height / 2) + (noise * height * 0.4);
                    
                    if (x === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                
                ctx.strokeStyle = '#4CAF50';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Draw loop markers on waveform
                const drawLoopMarker = (position, color) => {
                    const x = (position / this.duration) * width;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, height);
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 1;
                    ctx.stroke();
                };
                
                drawLoopMarker(this.loopStart, '#FF9800');
                drawLoopMarker(this.loopEnd, '#FF9800');
            }

            drawGraphEditor() {
                const ctx = this.graphCtx;
                const width = this.graphCanvas.width;
                const height = this.graphCanvas.height;
                
                ctx.clearRect(0, 0, width, height);
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, width, height);
                
                // Draw grid
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                
                // Vertical lines
                for (let x = 0; x <= width; x += width / 10) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, height);
                    ctx.stroke();
                }
                
                // Horizontal lines
                for (let y = 0; y <= height; y += height / 5) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(width, y);
                    ctx.stroke();
                }
                
                // Draw filter curve
                ctx.beginPath();
                ctx.moveTo(0, height);
                
                for (let x = 0; x < width; x++) {
                    const progress = x / width;
                    // Low-pass filter curve
                    const cutoff = Math.sin(progress * Math.PI) * 0.8 + 0.2;
                    const resonance = Math.sin(progress * Math.PI * 2) * 0.3 + 0.5;
                    
                    const y = height - (cutoff * height * 0.8 + resonance * height * 0.2);
                    ctx.lineTo(x, y);
                }
                
                ctx.strokeStyle = '#4CAF50';
                ctx.lineWidth = 3;
                ctx.stroke();
            }

            addParticles(count) {
                // Simple particle animation for feedback
                const particles = [];
                for (let i = 0; i < count; i++) {
                    particles.push({
                        x: Math.random() * this.particleCanvas.width,
                        y: Math.random() * this.particleCanvas.height,
                        vx: (Math.random() - 0.5) * 4,
                        vy: (Math.random() - 0.5) * 4,
                        radius: Math.random() * 10 + 5,
                        color: `hsl(${Math.random() * 360}, 70%, 60%)`,
                        life: 1.0
                    });
                }
                
                // Animate particles briefly
                const animateParticles = () => {
                    this.particleCtx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                    this.particleCtx.fillRect(0, 0, this.particleCanvas.width, this.particleCanvas.height);
                    
                    let allDead = true;
                    
                    particles.forEach(particle => {
                        if (particle.life <= 0) return;
                        
                        allDead = false;
                        particle.x += particle.vx;
                        particle.y += particle.vy;
                        particle.life -= 0.02;
                        
                        // Draw particle
                        this.particleCtx.beginPath();
                        this.particleCtx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
                        this.particleCtx.fillStyle = particle.color;
                        this.particleCtx.globalAlpha = particle.life;
                        this.particleCtx.fill();
                        this.particleCtx.globalAlpha = 1.0;
                    });
                    
                    if (!allDead) {
                        requestAnimationFrame(animateParticles);
                    }
                };
                
                animateParticles();
            }

            startAnimation() {
                // Initial drawings
                this.generateWaveform();
                this.drawGraphEditor();
                
                // Add some initial particles
                this.addParticles(3);
            }
        }

        // Initialize the app when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new MobileCollidoscope();
        });
    </script>
</body>
</html>
