<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4D Hypercube - Solid Face Rendering</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #000;
            color: white;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .container {
            display: flex;
            gap: 20px;
            max-width: 1400px;
        }
        
        .canvas-container {
            flex: 2;
        }
        
        .controls {
            width: 300px;
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 10px;
            color: #4fc3f7;
        }
        
        button {
            background: #2196f3;
            border: none;
            color: white;
            padding: 8px 16px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
        }
        
        button.active {
            background: #ff9800;
        }
        
        .debug-info {
            margin-top: 15px;
            padding: 10px;
            background: rgba(255, 0, 0, 0.1);
            border-radius: 5px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <h1>4D Hypercube - Solid Face Rendering</h1>
    
    <div class="container">
        <div class="canvas-container">
            <div id="sketch-holder"></div>
        </div>
        
        <div class="controls">
            <h3>Render Mode</h3>
            <button id="mode-solid" class="active">Solid Faces</button>
            <button id="mode-edges">Edges Only</button>
            <button id="mode-both">Faces + Edges</button>
            
            <h3>Face Style</h3>
            <button id="style-flat">Flat Shading</button>
            <button id="style-gradient">Gradient</button>
            <button id="style-checker">Checkerboard</button>
            
            <div class="debug-info">
                <div>Faces detected: <span id="face-count">0</span></div>
                <div>Faces rendered: <span id="rendered-count">0</span></div>
                <div>Debug: <span id="debug-info">Ready</span></div>
            </div>
        </div>
    </div>

    <script>
        // ===== SIMPLIFIED BUT ROBUST FACE RENDERER =====
        class SolidHypercubeRenderer {
            constructor() {
                this.vertices = [];
                this.edges = [];
                this.faces = [];
                this.cubeSize = 100;
            }
            
            createHypercube() {
                this.vertices = [];
                this.edges = [];
                this.faces = [];
                
                // Create 16 vertices - SIMPLIFIED: Just store coordinates
                for (let i = 0; i < 16; i++) {
                    this.vertices.push([
                        (i & 1) ? this.cubeSize : -this.cubeSize,
                        (i & 2) ? this.cubeSize : -this.cubeSize,
                        (i & 4) ? this.cubeSize : -this.cubeSize,
                        (i & 8) ? this.cubeSize : -this.cubeSize
                    ]);
                }
                
                // Create edges
                for (let i = 0; i < 16; i++) {
                    for (let j = i + 1; j < 16; j++) {
                        if (this.countDifferences(i, j) === 1) {
                            this.edges.push([i, j]);
                        }
                    }
                }
                
                // Create faces using a SIMPLIFIED approach
                this.createSimpleFaces();
            }
            
            createSimpleFaces() {
                // Create faces by finding squares (4 vertices that form a square in 4D)
                for (let i = 0; i < 16; i++) {
                    for (let j = i + 1; j < 16; j++) {
                        if (this.countDifferences(i, j) === 1) {
                            // For each edge, find the square it belongs to
                            let edgeDiff = this.getDifferenceIndex(i, j);
                            
                            for (let k = 0; k < 16; k++) {
                                if (k !== i && k !== j && this.countDifferences(i, k) === 1) {
                                    let diffIK = this.getDifferenceIndex(i, k);
                                    if (diffIK !== edgeDiff) {
                                        // Find the fourth vertex to complete the square
                                        let l = this.findFourthVertex(i, j, k, edgeDiff, diffIK);
                                        if (l !== -1) {
                                            // Check if we haven't added this face yet
                                            let face = [i, j, l, k].sort((a, b) => a - b);
                                            let faceKey = face.join('-');
                                            
                                            if (!this.faces.some(f => f.key === faceKey)) {
                                                this.faces.push({
                                                    vertices: [i, j, l, k],
                                                    key: faceKey,
                                                    color: color(
                                                        (i % 4) * 64,
                                                        (j % 4) * 64,
                                                        (k % 4) * 64
                                                    )
                                                });
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            findFourthVertex(i, j, k, diff1, diff2) {
                // The fourth vertex has bits that match:
                // - Same as j for diff1
                // - Same as k for diff2  
                // - Same as i for other bits
                let target = 0;
                for (let bit = 0; bit < 4; bit++) {
                    if (bit === diff1) {
                        target |= (j & (1 << bit));
                    } else if (bit === diff2) {
                        target |= (k & (1 << bit));
                    } else {
                        target |= (i & (1 << bit));
                    }
                }
                return target;
            }
            
            getDifferenceIndex(a, b) {
                for (let i = 0; i < 4; i++) {
                    if (((a >> i) & 1) !== ((b >> i) & 1)) {
                        return i;
                    }
                }
                return -1;
            }
            
            countDifferences(a, b) {
                let diff = 0;
                for (let k = 0; k < 4; k++) {
                    if (((a >> k) & 1) !== ((b >> k) & 1)) diff++;
                }
                return diff;
            }
            
            project4D(v, angleW) {
                let [x, y, z, w] = v;
                
                // Simple rotation in XW plane only
                let newX = x * cos(angleW) - w * sin(angleW);
                let newW = x * sin(angleW) + w * cos(angleW);
                
                // Perspective projection
                let scale = 300 / (400 - newW);
                return [newX * scale, y * scale, z * scale];
            }
            
            calculateFaceNormal(face, angleW) {
                if (face.vertices.length < 3) return [0, 0, 1];
                
                let v0 = this.project4D(this.vertices[face.vertices[0]], angleW);
                let v1 = this.project4D(this.vertices[face.vertices[1]], angleW);
                let v2 = this.project4D(this.vertices[face.vertices[2]], angleW);
                
                // 3D cross product for the projected points
                let u = [v1[0]-v0[0], v1[1]-v0[1], v1[2]-v0[2]];
                let v = [v2[0]-v0[0], v2[1]-v2[1], v2[2]-v0[2]];
                
                let normal = [
                    u[1]*v[2] - u[2]*v[1],
                    u[2]*v[0] - u[0]*v[2],
                    u[0]*v[1] - u[1]*v[0]
                ];
                
                // Normalize
                let len = sqrt(normal[0]*normal[0] + normal[1]*normal[1] + normal[2]*normal[2]);
                if (len > 0) {
                    normal = normal.map(n => n / len);
                }
                
                return normal;
            }
            
            isFaceVisible(face, angleW) {
                let normal = this.calculateFaceNormal(face, angleW);
                // Simple test: face is visible if normal points toward viewer (negative Z)
                return normal[2] < 0;
            }
            
            renderSolidFaces(angleW) {
                let renderedCount = 0;
                
                // Sort faces by depth for proper rendering
                let facesToRender = [];
                for (let face of this.faces) {
                    if (this.isFaceVisible(face, angleW)) {
                        // Calculate average Z depth for sorting
                        let avgZ = 0;
                        for (let vertIndex of face.vertices) {
                            let projected = this.project4D(this.vertices[vertIndex], angleW);
                            avgZ += projected[2];
                        }
                        avgZ /= face.vertices.length;
                        
                        facesToRender.push({face, depth: avgZ});
                    }
                }
                
                // Sort back to front
                facesToRender.sort((a, b) => b.depth - a.depth);
                
                // Render each face as a SOLID polygon
                for (let {face, depth} of facesToRender) {
                    let projected = face.vertices.map(idx => 
                        this.project4D(this.vertices[idx], angleW)
                    );
                    
                    // Brightness based on depth
                    let brightness = map(depth, -200, 200, 100, 255);
                    let faceColor = color(
                        red(face.color) * brightness/255,
                        green(face.color) * brightness/255, 
                        blue(face.color) * brightness/255
                    );
                    
                    // SOLID rendering - no transparency!
                    fill(faceColor);
                    stroke(0, 0, 0, 0); // No stroke for solid faces
                    
                    beginShape();
                    for (let p of projected) {
                        vertex(p[0], p[1], p[2]);
                    }
                    endShape(CLOSE);
                    
                    renderedCount++;
                }
                
                return renderedCount;
            }
            
            renderEdges(angleW) {
                stroke(255, 200);
                strokeWeight(2);
                noFill();
                
                for (let [i, j] of this.edges) {
                    let v1 = this.project4D(this.vertices[i], angleW);
                    let v2 = this.project4D(this.vertices[j], angleW);
                    line(v1[0], v1[1], v1[2], v2[0], v2[1], v2[2]);
                }
            }
        }

        // ===== MAIN SKETCH =====
        let renderer;
        let angleW = 0;
        let renderMode = 'solid';
        let faceStyle = 'flat';

        function setup() {
            let canvas = createCanvas(800, 800, WEBGL);
            canvas.parent('sketch-holder');
            
            renderer = new SolidHypercubeRenderer();
            renderer.createHypercube();
            
            setupControls();
            
            // Debug info
            document.getElementById('face-count').textContent = renderer.faces.length;
        }

        function draw() {
            background(0);
            
            // Basic rotation for viewing
            rotateX(frameCount * 0.01);
            rotateY(frameCount * 0.02);
            
            angleW += 0.02;
            
            let renderedFaces = 0;
            
            switch(renderMode) {
                case 'solid':
                    renderedFaces = renderer.renderSolidFaces(angleW);
                    break;
                case 'edges':
                    renderer.renderEdges(angleW);
                    break;
                case 'both':
                    renderedFaces = renderer.renderSolidFaces(angleW);
                    renderer.renderEdges(angleW);
                    break;
            }
            
            document.getElementById('rendered-count').textContent = renderedFaces;
            document.getElementById('debug-info').textContent = 
                `Angle: ${angleW.toFixed(2)} | Mode: ${renderMode}`;
        }

        function setupControls() {
            // Render mode buttons
            document.getElementById('mode-solid').addEventListener('click', () => {
                renderMode = 'solid';
                setActiveButton('mode-solid', ['mode-solid', 'mode-edges', 'mode-both']);
            });
            
            document.getElementById('mode-edges').addEventListener('click', () => {
                renderMode = 'edges';
                setActiveButton('mode-edges', ['mode-solid', 'mode-edges', 'mode-both']);
            });
            
            document.getElementById('mode-both').addEventListener('click', () => {
                renderMode = 'both';
                setActiveButton('mode-both', ['mode-solid', 'mode-edges', 'mode-both']);
            });
        }

        function setActiveButton(activeId, buttonIds) {
            buttonIds.forEach(id => {
                document.getElementById(id).classList.toggle('active', id === activeId);
            });
        }

        function windowResized() {
            resizeCanvas(800, 800);
        }
    </script>
</body>
</html>
